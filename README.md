# Инструкия:
После успешного установления проекта или клонирования его через GitHub перед запуском нужно настроить application.properties и базу данных. \
В свою базу данных на PostreSQL нужно добавить готовую базу, которая находится в проекте, в папке sql/scheme.sql.\
В application.properties нужно указать значение:\
**spring.datasource.url=your-url-database**\
**spring.datasource.username=your-username-database**\
**spring.datasource.password=your-password-database**\
Дополнительно вы можете указать время жизни JWT токенов в **app.lifetime**, или указать время проведения аукциона в **auction.time**.


# Функционал проекта:

# Контроллеры:
Всего в проекте имеется два контролера, для регистрации и для взаимодействия с аукционом.

## Контроллер **SecurityController** имеет два post метода, для регистрации и входа.
### Метод signup предназначен для регистрации пользователя
через DTO **registerRequest** в котором должна передаться все данные для заполнения регистрации происходит сначала проверка на наличие почты и логина в базе, если таковы имеются в базе пользователю возвращают статус **bad request** с предупреждением. После успешной проверки мы сохраняем пользователя через сервис **userService** методом **saveUser**, если что то пойдет не так пользователю вернут статус **internal server error**.
### Метод signin предназначен для входа пользователя
через DTO **loginRequest** передается нужные для входа данные, затем  мы пытаемся войти пользователя через эти данные, генерируя JWT токен для входа через класс **JwtCore** методом **generateToken()**, если данные были не верны через **BadCredentialsException** даем статус **Unauthorized**, в иной ошибке даем статус **internal server error**.

## Контроллер **AdvertisementController** нужен для взаимодействия с аукционом.
### Post метод **createAdvertisement** нужен для создании товара в аукцион
через DTO **AdvertisementRequest** передается данные для заполнения создания товара. Через **userService.findByEmail()** находим текущего пользователя и сразу же передаем его в **advertisementRequest.setUser()**, также в **advertisementRequest** ставим **setActive()** на true. Затем пытаемся создать товар через сервис **AdvertisementService** методом **saveAdvertisement** передавая наш DTO **advertisementRequest**. Если что-то пошло не так, возвращаем статус **internal server error**.
### Get метод **getUserAdvertisements** возвращает все товары текущего пользователя
Находим пользователя через сервис **userService.findByEmail()**, далее пытаемся найти товары с помощью сервиса **advertisementService** методом **getAdvertisementByUser** передавая в него нашего пользователя. Полученный список товаров мы возвращаем пользователю и давая статус **ok**, В ином случаи если произошла ошибка отдаем статус **internal server error**.
### Get метод **getActiveAdvertisements** возвращает все активные товары через или без фильтрации.
Пытаемся вернуть список активных товаров через сервис **advertisementService** методом **getActiveAdvertisements()**, переданными **title**, **minPrice**, **maxPrice** добавляем в качестве параметрах этому методу, и возвращаем наш полученный список с статусом **ok**. В ином случаи возвращаем статус **internal server error**.
### Post метод **removeAdvertisement** нужен для отключении товара по его id
для этого нужно передать только id товара. Пытаемся выключить значение active товара на false через сервис **advertisementService** методом **removeAdvertisement()** передавая ему наш id товара. В Хорошем раскладе возвращаем пользователю статус **ok** с сообщением об успешной отключении, в ином случаи, если произошла ошибка, даем статус **internal server error**.
### Post метод **placeBid**, главный метод в котором происходит процесс аукциона, создание ставок на товар, 
передается id товара и сумма ставки. Для начало берем пользователя через **userService.findByEmail()**, затем пытаемся поставить ставку через **bidService** методом **placeBid()** передавая пользователя, id товара и сумму ставки (логика метода будет позже рассказа в разделе сервис). В хорошем случаи передаем статус **ok** и сообщение об успешной ставки, в случаи ошибки со стороны пользователя будет передан статус **bad request** с сообщением об ошибке, в случаи ошибки со стороны сервера пользователю будет возращен статус **internal server error**.

# Сервисы:

## Сервис **AdvertisementService**, логика товаров аукциона
### Метод **saveAdvertisement()** нужен для сохранении товара в базу данных
создаем новый объект класса и заполняем его данные с помощью переданного DTO **advertisementRequest**. Пытаемся сохранять объект в репозитории **advertisementRepository** методом **save()** и возвращаем его, в плохом случаи возвращаем ошибку.
### Метод **getAdvertisementByUser()** возращает список товаров пользователя
Пытаемся найти список товаров пользователя через репозитории **advertisementRepository** методом **findByUser()** передавая пользователя, в лучшем случаи готовый список возвращаем, в плохом случаи возвращаем ошибку.
### Метод **getActiveAdvertisements()** возвращает список активных товаров
Пытаемся найти список активных товаров через репозитории **advertisementRepository** методом **findActiveAdvertisements()** передавая туда **title**, **minPrice**, **maxPrice**. В лучшем случаи мы возвращаем этот список, в худшем случаи возвращаем ошибку.
### Метод **removeAdvertisement()** ставит значение **active** товара на **false**
Пытаемся найти товар по id с помощью репозитории **advertisementRepository** методом **findById()** передавая id, дальше у полученного товара меняем **setActive()** на false и сохраняем товар в репозитории с помощью метода **save()**.В плохом случаи мы возвращаем ошибку

## Сервис **BidService**, логика ставок на товары аукциона
### Метод **placeBid()** нужен для размещения новой ставки на товар
Создаем новый объект класса **Bid** и заполняем его данные с помощью переданных параметров пользователя, id объявления **advertisementId**, и суммы ставки **amount**. Пытаемся найти товар через репозиторий **advertisementRepository** методом **findById()** и проверяем, активен ли аукцион. Если товар неактивен или сумма ставки меньше текущей цены, возвращаем ошибку. Если время окончания аукциона не установлено, устанавливаем его и сохраняем товар. Сохраняем ставку в репозитории **bidRepository**, обновляем текущую цену товара, уведомляем предыдущего участника и продавца с помощью сервиса **notificationService**. В плохом случае возвращаем ошибку.
### Метод **checkAuctions()** проверяет активные аукционы и завершает их при необходимости
Метод выполняется по расписанию каждые 60 секунд. Пытаемся найти список активных товаров с истекшим временем аукциона через репозиторий **advertisementRepository** методом **findAllByActiveTrueAndAuctionEndTimeBefore()**. Для каждого завершенного аукциона устанавливаем активность товара на false, сохраняем его, уведомляем продавца и победителя с помощью сервиса **notificationService**.

## Сервис **NotificationService**, логика уведомлений
### Метод **notifyPreviousBidder()** уведомляет предыдущего участника о перебивании его ставки
Пытаемся найти последнюю ставку, сделанную не текущим пользователем , сортируя список ставок **advertisement.getBids()** по времени в обратном порядке. Если такая ставка найдена, отправляем уведомление с помощью логгера **logger.info()** с текстом, что его ставка перебита.
### Метод **notifySeller()** уведомляет продавца о новой ставке
Отправляем уведомление с помощью логгера **logger.info()** на email продавца, указанного в объявлении **advertisement.getUser().getEmail()**, с текстом о том, что на его товар сделана новая ставка.
### Метод **notifyWinner()** уведомляет победителя аукциона
Отправляем уведомление с помощью логгера **logger.info()** на email пользователя **user.getEmail()** с поздравлением о победе в аукционе.
### Метод **notifySellerEnd()** уведомляет продавца об окончании аукциона
Отправляем уведомление с помощью логгера **logger.info()** на email продавца **advertisement.getUser().getEmail()** о том, что его аукцион успешно завершен.

## Сервис **UserService**, логика управления пользователями
### Метод **saveUser()** нужен для сохранения нового пользователя
Создаем новый объект класса **User** и заполняем его данные с помощью переданного DTO **RegisterRequest**. Устанавливаем email, имя пользователя, и шифруем пароль с помощью **passwordEncoder**. Пытаемся сохранить объект в репозитории **userRepository** методом **save()**. В случае успеха возвращаем сохраненного пользователя и логируем успех через **logger.info()**. В случае ошибки выбрасываем исключение.
### Метод **findByEmail()** находит пользователя по email
Пытаемся найти пользователя через репозиторий **userRepository** методом **findByEmail()**. Если пользователь найден, возвращаем его. В противном случае выбрасываем исключение с сообщением "Пользователь не найден".
### Метод **findByUsername()** находит пользователя по имени пользователя
Пытаемся найти пользователя через репозиторий **userRepository** методом **findByUsername()**. Если пользователь найден, возвращаем его. В противном случае выбрасываем исключение с сообщением "Пользователь не найден".
